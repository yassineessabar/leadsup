#!/usr/bin/env node

/**
 * Complete End-to-End Email Testing Suite
 * 
 * This script tests the entire email flow:
 * 1. Domain and sender verification
 * 2. Campaign setup verification
 * 3. Outbound email sending
 * 4. Inbound email webhook processing
 * 5. Database storage verification
 */

require('dotenv').config({ path: '.env.local' });
const { spawn } = require('child_process');

// Test configuration
const CONFIG = {
  baseUrl: 'http://localhost:3008',
  testEmail: 'test@example.com', // Change this to your test email
  senderEmail: 'contact@leadsup.io',
  automationAuth: Buffer.from('admin:password').toString('base64')
};

// Colors for output
const colors = {
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  reset: '\x1b[0m',
  bold: '\x1b[1m'
};

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function section(title) {
  log('\n' + '='.repeat(60), 'blue');
  log(`ğŸ“‹ ${title}`, 'bold');
  log('='.repeat(60), 'blue');
}

function step(number, description) {
  log(`\nğŸ” Step ${number}: ${description}`, 'yellow');
  log('-'.repeat(40), 'yellow');
}

async function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function runCurl(args) {
  return new Promise((resolve, reject) => {
    const curl = spawn('curl', args);
    let output = '';
    let errorOutput = '';
    
    curl.stdout.on('data', (data) => {
      output += data.toString();
    });
    
    curl.stderr.on('data', (data) => {
      errorOutput += data.toString();
    });
    
    curl.on('close', (code) => {
      resolve({ code, output, error: errorOutput });
    });
    
    curl.on('error', (error) => {
      reject(error);
    });
  });
}

async function checkPrerequisites() {
  step(1, 'Checking Prerequisites');
  
  const checks = [
    { name: 'SENDGRID_API_KEY', value: process.env.SENDGRID_API_KEY },
    { name: 'NEXT_PUBLIC_SUPABASE_URL', value: process.env.NEXT_PUBLIC_SUPABASE_URL },
    { name: 'SUPABASE_SERVICE_ROLE_KEY', value: process.env.SUPABASE_SERVICE_ROLE_KEY }
  ];
  
  let allGood = true;
  
  for (const check of checks) {
    if (check.value) {
      log(`âœ… ${check.name}: Configured`, 'green');
    } else {
      log(`âŒ ${check.name}: Missing`, 'red');
      allGood = false;
    }
  }
  
  // Check if dev server is running
  try {
    const result = await runCurl([
      '-s', '-o', '/dev/null', '-w', '%{http_code}',
      `${CONFIG.baseUrl}/`
    ]);
    
    const statusCode = parseInt(result.output.trim());
    if (statusCode >= 200 && statusCode < 400) {
      log('âœ… Development server: Running', 'green');
    } else {
      log('âŒ Development server: Not responding', 'red');
      allGood = false;
    }
  } catch (error) {
    log('âŒ Development server: Cannot connect', 'red');
    allGood = false;
  }
  
  if (!allGood) {
    log('\nğŸ’¡ Please fix the issues above before proceeding', 'yellow');
    process.exit(1);
  }
  
  log('\nâœ… All prerequisites met!', 'green');
  return true;
}

async function testSendGridOutbound() {
  step(2, 'Testing SendGrid Outbound Email');
  
  try {
    const sgMail = require('@sendgrid/mail');
    sgMail.setApiKey(process.env.SENDGRID_API_KEY);
    
    const testEmail = {
      to: CONFIG.testEmail,
      from: {
        email: CONFIG.senderEmail,
        name: 'LeadsUp Test System'
      },
      subject: `End-to-End Email Test - ${new Date().toISOString()}`,
      html: `
        <h2>ğŸ§ª End-to-End Email Test</h2>
        <p>This email confirms that your outbound email system is working correctly.</p>
        <p><strong>Test Details:</strong></p>
        <ul>
          <li>Sent from: ${CONFIG.senderEmail}</li>
          <li>Test ID: E2E-${Date.now()}</li>
          <li>System: Domain-based sender accounts</li>
          <li>Timestamp: ${new Date().toISOString()}</li>
        </ul>
        <p><strong>Please reply to this email</strong> to test the inbound functionality.</p>
        <hr>
        <p><small>Generated by LeadsUp End-to-End Test Suite</small></p>
      `,
      text: `End-to-End Email Test

This email confirms that your outbound email system is working correctly.

Test Details:
- Sent from: ${CONFIG.senderEmail}
- Test ID: E2E-${Date.now()}
- System: Domain-based sender accounts
- Timestamp: ${new Date().toISOString()}

Please reply to this email to test the inbound functionality.

Generated by LeadsUp End-to-End Test Suite`,
      replyTo: CONFIG.senderEmail
    };
    
    log('ğŸ“¤ Sending test email...');
    log(`   To: ${testEmail.to}`);
    log(`   From: ${testEmail.from.email}`);
    log(`   Subject: ${testEmail.subject}`);
    
    const result = await sgMail.send(testEmail);
    
    log('âœ… Email sent successfully!', 'green');
    log(`ğŸ“¨ Message ID: ${result[0].headers['x-message-id']}`);
    log(`ğŸ“Š Status Code: ${result[0].statusCode}`);
    
    return {
      success: true,
      messageId: result[0].headers['x-message-id'],
      statusCode: result[0].statusCode
    };
    
  } catch (error) {
    log(`âŒ SendGrid test failed: ${error.message}`, 'red');
    if (error.response && error.response.body) {
      log(`ğŸ“‹ Error details: ${JSON.stringify(error.response.body)}`, 'red');
    }
    return { success: false, error: error.message };
  }
}

async function testWebhookEndpoint() {
  step(3, 'Testing Webhook Endpoint');
  
  try {
    log('ğŸ” Testing webhook availability...');
    
    const result = await runCurl([
      '-s', '-X', 'GET',
      `${CONFIG.baseUrl}/api/webhooks/sendgrid`
    ]);
    
    if (result.code === 0) {
      try {
        const response = JSON.parse(result.output);
        if (response.status && response.status.includes('SendGrid')) {
          log('âœ… Webhook endpoint is active', 'green');
          log(`ğŸ“¡ Provider: ${response.provider}`);
          return { success: true, response };
        }
      } catch (parseError) {
        log('âš ï¸ Webhook responded but with unexpected format', 'yellow');
      }
    }
    
    log('âŒ Webhook endpoint not responding correctly', 'red');
    return { success: false };
    
  } catch (error) {
    log(`âŒ Webhook test failed: ${error.message}`, 'red');
    return { success: false, error: error.message };
  }
}

async function testInboundWebhook() {
  step(4, 'Testing Inbound Email Processing');
  
  try {
    log('ğŸ“¥ Sending simulated inbound email...');
    
    const testId = `E2E-INBOUND-${Date.now()}`;
    
    const result = await runCurl([
      '-s', '-X', 'POST',
      `${CONFIG.baseUrl}/api/webhooks/sendgrid`,
      '-F', 'from=test-prospect@company.com',
      '-F', `to=${CONFIG.senderEmail}`,
      '-F', `subject=Re: End-to-End Email Test (${testId})`,
      '-F', `text=Hi! I received your test email and the system is working great. This is my reply to test the inbound functionality.`,
      '-F', `html=<p>Hi! I received your test email and the system is working great.</p><p>This is my reply to test the inbound functionality.</p><p>Test ID: ${testId}</p>`,
      '-F', `envelope={"from": "test-prospect@company.com", "to": ["${CONFIG.senderEmail}"]}`,
      '-F', `headers={"Message-Id": "<${testId}@company.com>", "Date": "${new Date().toISOString()}"}`,
      '-F', 'charsets={"from": "UTF-8", "to": "UTF-8", "subject": "UTF-8", "text": "UTF-8"}',
      '-F', 'spam_score=0.1',
      '-F', 'spam_report=',
      '-F', 'attachments=0'
    ]);
    
    log(`ğŸ“Š Webhook response code: ${result.code}`);
    
    if (result.output) {
      try {
        const response = JSON.parse(result.output);
        log(`ğŸ“‹ Response: ${JSON.stringify(response, null, 2)}`);
        
        if (response.success) {
          log('âœ… Inbound email processed successfully!', 'green');
          if (response.messageId) {
            log(`ğŸ“¨ Message ID: ${response.messageId}`);
          }
          if (response.conversationId) {
            log(`ğŸ§µ Conversation ID: ${response.conversationId}`);
          }
          return { success: true, response, testId };
        } else {
          log('âš ï¸ Webhook processed but reported failure', 'yellow');
          log(`   Error: ${response.error || 'Unknown error'}`);
          return { success: false, response, testId };
        }
      } catch (parseError) {
        log('âš ï¸ Could not parse webhook response', 'yellow');
        log(`   Raw output: ${result.output.substring(0, 200)}...`);
        return { success: false, testId };
      }
    } else {
      log('âŒ No response from webhook', 'red');
      return { success: false, testId };
    }
    
  } catch (error) {
    log(`âŒ Inbound webhook test failed: ${error.message}`, 'red');
    return { success: false, error: error.message };
  }
}

async function testEmailAutomation() {
  step(5, 'Testing Email Automation API');
  
  try {
    log('ğŸ¤– Testing automated email sending...');
    
    const result = await runCurl([
      '-s', '-X', 'POST',
      `${CONFIG.baseUrl}/api/campaigns/automation/send-emails`,
      '-H', 'Content-Type: application/json',
      '-H', `Authorization: Basic ${CONFIG.automationAuth}`,
      '-w', '\\nHTTP_CODE:%{http_code}'
    ]);
    
    const lines = result.output.split('\n');
    const httpCodeLine = lines.find(line => line.startsWith('HTTP_CODE:'));
    const httpCode = httpCodeLine ? parseInt(httpCodeLine.split(':')[1]) : 0;
    const jsonResponse = lines.find(line => line.trim().startsWith('{'));
    
    log(`ğŸ“Š HTTP Status: ${httpCode}`);
    
    if (httpCode === 200 && jsonResponse) {
      try {
        const response = JSON.parse(jsonResponse);
        log('âœ… Automation API responded successfully', 'green');
        log(`ğŸ“§ Emails sent: ${response.sent || 0}`);
        log(`âŒ Failed: ${response.failed || 0}`);
        
        if (response.features_used) {
          log('ğŸš€ Features confirmed:', 'blue');
          response.features_used.forEach(feature => log(`   ${feature}`));
        }
        
        return { success: true, response };
      } catch (parseError) {
        log('âš ï¸ API responded but JSON parsing failed', 'yellow');
        return { success: false };
      }
    } else {
      log(`âŒ Automation API failed (HTTP ${httpCode})`, 'red');
      return { success: false, httpCode };
    }
    
  } catch (error) {
    log(`âŒ Automation test failed: ${error.message}`, 'red');
    return { success: false, error: error.message };
  }
}

async function verifyDatabaseStorage() {
  step(6, 'Verifying Database Storage');
  
  try {
    const { createClient } = require('@supabase/supabase-js');
    const supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL,
      process.env.SUPABASE_SERVICE_ROLE_KEY
    );
    
    log('ğŸ” Checking recent email activity...');
    
    // Check for recent outbound emails
    const { data: outbound, error: outboundError } = await supabase
      .from('inbox_messages')
      .select('id, contact_email, sender_email, subject, direction, created_at')
      .eq('direction', 'outbound')
      .order('created_at', { ascending: false })
      .limit(3);
    
    if (!outboundError && outbound) {
      log(`ğŸ“¤ Recent outbound emails: ${outbound.length}`);
      outbound.forEach((msg, i) => {
        log(`   ${i + 1}. To: ${msg.contact_email} | Subject: ${msg.subject}`);
      });
    }
    
    // Check for recent inbound emails
    const { data: inbound, error: inboundError } = await supabase
      .from('inbox_messages')
      .select('id, contact_email, sender_email, subject, direction, created_at')
      .eq('direction', 'inbound')
      .order('created_at', { ascending: false })
      .limit(3);
    
    if (!inboundError && inbound) {
      log(`ğŸ“¥ Recent inbound emails: ${inbound.length}`);
      inbound.forEach((msg, i) => {
        log(`   ${i + 1}. From: ${msg.contact_email} | Subject: ${msg.subject}`);
      });
    }
    
    // Check campaign senders
    const { data: senders, error: sendersError } = await supabase
      .from('campaign_senders')
      .select('id, email, campaign_id, is_active')
      .eq('is_active', true)
      .limit(5);
    
    if (!sendersError && senders) {
      log(`ğŸ‘¥ Active campaign senders: ${senders.length}`);
      senders.forEach((sender, i) => {
        log(`   ${i + 1}. ${sender.email} (Campaign: ${sender.campaign_id})`);
      });
    }
    
    log('âœ… Database verification complete', 'green');
    return {
      success: true,
      stats: {
        outbound: outbound?.length || 0,
        inbound: inbound?.length || 0,
        senders: senders?.length || 0
      }
    };
    
  } catch (error) {
    log(`âŒ Database verification failed: ${error.message}`, 'red');
    return { success: false, error: error.message };
  }
}

async function generateTestReport(results) {
  section('ğŸ“Š END-TO-END TEST RESULTS');
  
  const tests = [
    { name: 'Prerequisites Check', result: results.prerequisites },
    { name: 'SendGrid Outbound', result: results.outbound },
    { name: 'Webhook Endpoint', result: results.webhook },
    { name: 'Inbound Processing', result: results.inbound },
    { name: 'Email Automation', result: results.automation },
    { name: 'Database Storage', result: results.database }
  ];
  
  tests.forEach(test => {
    const status = test.result?.success ? 'âœ… PASS' : 'âŒ FAIL';
    const color = test.result?.success ? 'green' : 'red';
    log(`${status} ${test.name}`, color);
  });
  
  const passedTests = tests.filter(t => t.result?.success).length;
  const totalTests = tests.length;
  
  log(`\nğŸ“ˆ Overall Score: ${passedTests}/${totalTests} tests passed`);
  
  if (passedTests === totalTests) {
    log('\nğŸ‰ ALL TESTS PASSED!', 'green');
    log('âœ… Your email system is fully functional and ready for production!', 'green');
    
    log('\nğŸš€ What this means:', 'blue');
    log('â€¢ Outbound emails are sending via SendGrid');
    log('â€¢ Inbound emails are being captured via webhook');
    log('â€¢ Domain-based sender system is working');
    log('â€¢ Database storage is functioning correctly');
    log('â€¢ Email automation features are operational');
    
    log('\nğŸ“§ Next steps:', 'yellow');
    log('1. Check your test email for the sent message');
    log('2. Reply to that email to test real inbound flow');
    log('3. Configure SendGrid Inbound Parse for production');
    log('4. Monitor the system with real campaign data');
    
  } else {
    log('\nâš ï¸ Some tests failed - system needs attention', 'yellow');
    
    const failedTests = tests.filter(t => !t.result?.success);
    log('\nğŸ”§ Failed components:', 'red');
    failedTests.forEach(test => {
      log(`â€¢ ${test.name}: ${test.result?.error || 'Unknown error'}`);
    });
    
    log('\nğŸ’¡ Troubleshooting tips:', 'yellow');
    log('â€¢ Check environment variables in .env.local');
    log('â€¢ Verify SendGrid domain authentication');
    log('â€¢ Ensure development server is running');
    log('â€¢ Check database connectivity and permissions');
  }
  
  return passedTests === totalTests;
}

async function main() {
  console.clear();
  log('ğŸ§ª COMPLETE END-TO-END EMAIL TESTING SUITE', 'bold');
  log('Testing both outbound and inbound email functionality\n', 'blue');
  
  const results = {};
  
  try {
    // Run all tests
    results.prerequisites = await checkPrerequisites();
    results.outbound = await testSendGridOutbound();
    results.webhook = await testWebhookEndpoint();
    results.inbound = await testInboundWebhook();
    results.automation = await testEmailAutomation();
    results.database = await verifyDatabaseStorage();
    
    // Generate final report
    const allPassed = await generateTestReport(results);
    
    process.exit(allPassed ? 0 : 1);
    
  } catch (error) {
    log(`\nğŸ’¥ Test suite crashed: ${error.message}`, 'red');
    process.exit(1);
  }
}

// Run the complete test suite
if (require.main === module) {
  main();
}

module.exports = {
  checkPrerequisites,
  testSendGridOutbound,
  testInboundWebhook,
  testEmailAutomation,
  verifyDatabaseStorage
};